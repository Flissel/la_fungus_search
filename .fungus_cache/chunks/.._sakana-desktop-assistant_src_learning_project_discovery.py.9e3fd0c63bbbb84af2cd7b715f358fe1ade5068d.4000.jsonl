# file: ..\sakana-desktop-assistant\src\learning\project_discovery.py | lines: 1-535 | window: 4000
"""
Project Discovery through evolutionary exploration
"""

import os
import json
import asyncio
import subprocess
from pathlib import Path
from typing import Dict, Any, List, Optional, Set, Tuple
from dataclasses import dataclass
from datetime import datetime
import logging

from .knowledge_accumulator import KnowledgeAccumulator

logger = logging.getLogger(__name__)

@dataclass
class DiscoveredProject:
    """Represents a discovered project with its characteristics"""
    name: str
    path: str
    type: str  # python, javascript, rust, etc.
    discovered_at: str = datetime.now().isoformat()
    characteristics: Dict[str, Any] = None
    capabilities: List[str] = None
    
    def __post_init__(self):
        if self.characteristics is None:
            self.characteristics = {}
        if self.capabilities is None:
            self.capabilities = []

class ProjectDiscoveryLearner:
    """Discovers projects and their capabilities through exploration"""
    
    def __init__(self, base_path: str = None):
        self.base_path = Path(base_path or os.path.expanduser("~"))
        self.discovered_projects = {}
        self.project_patterns = []
        self.capability_genome = {
            'file_patterns': [],  # Will discover
            'command_patterns': [],  # Will discover
            'structure_patterns': [],  # Will discover
            'exploration_depth': 3,
            'mutation_rate': 0.3
        }
        
        # Knowledge accumulator for projects
        self.knowledge = KnowledgeAccumulator(
            knowledge_dir=os.path.expanduser("~/.sakana/project_knowledge")
        )
        
        # Discovery session
        self.session_start = datetime.now()
        self.new_discoveries = []
        
    async def discover_projects(self, target_path: str = None) -> List[DiscoveredProject]:
        """Discover projects through evolutionary exploration"""
        
        search_path = Path(target_path) if target_path else self.base_path
        logger.info(f"Starting project discovery in: {search_path}")
        
        # Get already known projects
        known_projects = self._get_known_projects()
        logger.info(f"Already know {len(known_projects)} projects from previous sessions")
        
        # Generate exploration strategies
        strategies = self._generate_exploration_strategies()
        discovered = []
        
        for strategy in strategies:
            projects = await self._explore_with_strategy(search_path, strategy, known_projects)
            discovered.extend(projects)
        
        # Record discoveries
        for project in discovered:
            if project.path not in known_projects:
                self.new_discoveries.append(project)
                self.knowledge.add_discovered_command(f"project:{project.name}", {
                    'path': project.path,
                    'type': project.type,
                    'capabilities': project.capabilities
                })
        
        logger.info(f"Discovered {len(self.new_discoveries)} new projects")
        return discovered
    
    def _generate_exploration_strategies(self) -> List[Dict[str, Any]]:
        """Generate strategies for finding projects"""
        
        strategies = []
        
        # File-based detection strategies
        file_indicators = [
            # Python projects
            {'files': ['setup.py', 'pyproject.toml', 'requirements.txt'], 'type': 'python'},
            {'files': ['manage.py'], 'type': 'django'},
            {'files': ['Pipfile'], 'type': 'python-pipenv'},
            
            # JavaScript projects  
            {'files': ['package.json'], 'type': 'javascript'},
            {'files': ['tsconfig.json'], 'type': 'typescript'},
            {'files': ['angular.json'], 'type': 'angular'},
            {'files': ['next.config.js'], 'type': 'nextjs'},
            
            # Other languages
            {'files': ['Cargo.toml'], 'type': 'rust'},
            {'files': ['go.mod'], 'type': 'golang'},
            {'files': ['pom.xml'], 'type': 'java-maven'},
            {'files': ['build.gradle'], 'type': 'java-gradle'},
            {'files': ['Gemfile'], 'type': 'ruby'},
            {'files': ['.csproj'], 'type': 'csharp'},
            
            # Meta files
            {'files': ['.git'], 'type': 'git-repo'},
            {'files': ['Dockerfile'], 'type': 'docker'},
            {'files': ['docker-compose.yml'], 'type': 'docker-compose'},
            {'files': ['Makefile'], 'type': 'make-project'},
            
            # Documentation projects
            {'files': ['mkdocs.yml'], 'type': 'mkdocs'},
            {'files': ['_config.yml'], 'type': 'jekyll'},
            {'files': ['book.toml'], 'type': 'mdbook'},
        ]
        
        # Learn from previously discovered patterns
        if self.capability_genome['file_patterns']:
            file_indicators.extend(self.capability_genome['file_patterns'])
        
        # Generate strategies with mutations
        for indicator in file_indicators:
            # Original strategy
            strategies.append({
                'method': 'file_check',
                'indicator': indicator
            })
            
            # Mutated strategies
            if self.capability_genome['mutation_rate'] > 0:
                # Try variations of file names
                for file in indicator['files']:
                    base = file.rsplit('.', 1)[0] if '.' in file else file
                    mutations = [
                        f"{base}.yaml",
                        f"{base}.yml", 
                        f"{base}.json",
                        f"{base}.config",
                        f".{base}",
                        f"{base}file"
                    ]
                    for mutation in mutations:
                        strategies.append({
                            'method': 'file_check',
                            'indicator': {
                                'files': [mutation],
                                'type': f"{indicator['type']}-variant"
                            }
                        })
        
        # Command-based detection strategies
        command_strategies = [
            {'command': 'npm', 'args': ['list'], 'type': 'npm-project'},
            {'command': 'yarn', 'args': ['list'], 'type': 'yarn-project'},
            {'command': 'poetry', 'args': ['show'], 'type': 'poetry-project'},
            {'command': 'cargo', 'args': ['metadata'], 'type': 'cargo-project'},
        ]
        
        for cmd_strategy in command_strategies:
            strategies.append({
                'method': 'command_probe',
                'indicator': cmd_strategy
            })
        
        return strategies
    
    async def _explore_with_strategy(self, base_path: Path, strategy: Dict[str, Any], 
                                   known_projects: Set[str]) -> List[DiscoveredProject]:
        """Explore using a specific strategy"""
        
        discovered = []
        
        if strategy['method'] == 'file_check':
            # Search for indicator files
            indicator = strategy['indicator']
            
            for root, dirs, files in os.walk(base_path):
                root_path = Path(root)
                
                # Skip already known projects
                if str(root_path) in known_projects:
                    dirs[:] = []  # Don't descend into known projects
                    continue
                
                # Skip hidden and system directories
                dirs[:] = [d for d in dirs if not d.startswith('.') and d not in 
                          ['node_modules', 'venv', 'env', '__pycache__', 'dist', 'build']]
                
                # Check for indicator files
                for indicator_file in indicator['files']:
                    if indicator_file in files or indicator_file in dirs:
                        project = await self._analyze_project(root_path, indicator['type'])
                        if project:
                            discovered.append(project)
                            dirs[:] = []  # Don't descend further
                            break
                
                # Limit depth
                depth = len(root_path.parts) - len(base_path.parts)
                if depth >= self.capability_genome['exploration_depth']:
                    dirs[:] = []
        
        elif strategy['method'] == 'command_probe':
            # Try running commands to detect project types
            indicator = strategy['indicator']
            
            for root, dirs, _ in os.walk(base_path):
                root_path = Path(root)
                
                # Skip known projects
                if str(root_path) in known_projects:
                    dirs[:] = []
                    continue
                
                # Try command
                try:
                    result = await asyncio.create_subprocess_exec(
                        indicator['command'],
                        *indicator['args'],
                        cwd=root_path,
                        stdout=asyncio.subprocess.PIPE,
                        stderr=asyncio.subprocess.PIPE
                    )
                    
                    stdout, stderr = await asyncio.wait_for(result.communicate(), timeout=2.0)
                    
                    if result.returncode == 0:
                        project = await self._analyze_project(root_path, indicator['type'])
                        if project:
                            discovered.append(project)
                            dirs[:] = []
                
                except (asyncio.TimeoutError, FileNotFoundError, OSError):
                    pass
                
                # Limit depth
                depth = len(root_path.parts) - len(base_path.parts)
                if depth >= self.capability_genome['exploration_depth']:
                    dirs[:] = []
        
        return discovered
    
    async def _analyze_project(self, project_path: Path, project_type: str) -> Optional[DiscoveredProject]:
        """Analyze a discovered project to understand its capabilities"""
        
        logger.info(f"Analyzing project at: {project_path}")
        
        project = DiscoveredProject(
            name=project_path.name,
            path=str(project_path),
            type=project_type
        )
        
        # Discover capabilities through exploration
        capabilities = []
        
        # Check for common capability indicators
        capability_checks = [
            # Build/run capabilities
            (['Makefile'], 'make'),
            (['package.json'], 'npm-scripts'),
            (['setup.py'], 'python-setup'),
            (['docker-compose.yml', 'docker-compose.yaml'], 'docker-compose'),
            
            # Testing capabilities
            (['pytest.ini', 'test/', 'tests/'], 'testing'),
            (['jest.config.js', 'jest.config.json'], 'jest-testing'),
            (['.github/workflows/', '.gitlab-ci.yml'], 'ci-cd'),
            
            # Documentation
            (['README.md', 'README.rst', 'README.txt'], 'documented'),
            (['docs/', 'documentation/'], 'has-docs'),
            
            # Development tools
            (['.eslintrc', '.prettierrc', '.editorconfig'], 'code-standards'),
            (['.pre-commit-config.yaml'], 'pre-commit'),
        ]
        
        for files, capability in capability_checks:
            for file in files:
                if (project_path / file).exists():
                    capabilities.append(capability)
                    break
        
        # Discover commands that work in this project
        project_commands = await self._discover_project_commands(project_path)
        if project_commands:
            capabilities.extend([f"cmd:{cmd}" for cmd in project_commands])
        
        project.capabilities = capabilities
        
        # Extract additional characteristics
        project.characteristics = {
            'size': sum(1 for _ in project_path.rglob('*') if _.is_file()),
            'has_git': (project_path / '.git').exists(),
            'discovered_capabilities': len(capabilities),
            'last_modified': datetime.fromtimestamp(project_path.stat().st_mtime).isoformat()
        }
        
        return project
    
    async def _discover_project_commands(self, project_path: Path) -> List[str]:
        """Discover what commands work in this project"""
        
        discovered_commands = []
        
        # Common project commands to try
        test_commands = [
            # Python
            ['python', '--version'],
            ['pip', 'list'],
            ['pytest', '--version'],
            
            # JavaScript
            ['npm', 'run'],
            ['yarn', 'run'],
            ['npx', '--version'],
            
            # Build tools
            ['make', '-n'],
            ['gradle', '--version'],
            ['cargo', '--version'],
            
            # Generic
            ['test', '-f', 'Makefile'],
            ['git', 'status'],
        ]
        
        for cmd_parts in test_commands:
            try:
                result = await asyncio.create_subprocess_exec(
                    *cmd_parts,
                    cwd=project_path,
                    stdout=asyncio.subprocess.PIPE,
                    stderr=asyncio.subprocess.PIPE
                )
                
                await asyncio.wait_for(result.communicate(), timeout=1.0)
                
                if result.returncode == 0:
                    discovered_commands.append(cmd_parts[0])
            
            except (asyncio.TimeoutError, FileNotFoundError, OSError):
                pass
        
        return list(set(discovered_commands))
    
    def _get_known_projects(self) -> Set[str]:
        """Get set of already known project paths"""
        
        known = set()
        for cmd, data in self.knowledge.permanent_commands.get('commands', {}).items():
            if cmd.startswith('project:'):
                metadata = data.get('metadata', {})
                if 'path' in metadata:
                    known.add(metadata['path'])
        
        return known
    
    async def evolve_project_understanding(self, project: DiscoveredProject):
        """Evolve understanding of a specific project through exploration"""
        
        logger.info(f"Evolving understanding of project: {project.name}")
        
        # Try various exploration strategies
        strategies = [
            # Read configuration files
            self._explore_config_files,
            # Analyze code structure
            self._explore_code_structure,
            # Discover hidden capabilities
            self._explore_hidden_features,
            # Learn project-specific commands
            self._explore_custom_commands,
        ]
        
        for strategy in strategies:
            try:
                new_capabilities = await strategy(project)
                project.capabilities.extend(new_capabilities)
            except Exception as e:
                logger.debug(f"Strategy failed: {e}")
        
        # Update knowledge base
        self.knowledge.add_discovered_command(f"project:{project.name}", {
            'path': project.path,
            'type': project.type,
            'capabilities': project.capabilities,
            'evolved': True
        })
    
    async def _explore_config_files(self, project: DiscoveredProject) -> List[str]:
        """Explore configuration files to understand project better"""
        
        capabilities = []
        project_path = Path(project.path)
        
        # Look for package.json scripts
        if (project_path / 'package.json').exists():
            try:
                with open(project_path / 'package.json') as f:
                    data = json.load(f)
                    if 'scripts' in data:
                        for script_name in data['scripts']:
                            capabilities.append(f"npm-script:{script_name}")
            except:
                pass
        
        # Look for Makefile targets
        if (project_path / 'Makefile').exists():
            try:
                result = await asyncio.create_subprocess_exec(
                    'make', '-n', 'help',
                    cwd=project_path,
                    stdout=asyncio.subprocess.PIPE,
                    stderr=asyncio.subprocess.PIPE
                )
                stdout, _ = await asyncio.wait_for(result.communicate(), timeout=2.0)
                # Parse make targets from output
                # This is simplified - real parsing would be more complex
                capabilities.append("make-targets:discovered")
            except:
                pass
        
        return capabilities
    
    async def _explore_code_structure(self, project: DiscoveredProject) -> List[str]:
        """Analyze code structure to infer capabilities"""
        
        capabilities = []
        project_path = Path(project.path)
        
        # Check for common patterns
        patterns = {
            'src/': 'structured-code',
            'lib/': 'library-project',
            'bin/': 'has-executables',
            'scripts/': 'has-scripts',
            'migrations/': 'database-project',
            'models/': 'has-data-models',
            'routes/': 'web-framework',
            'components/': 'component-based',
        }
        
        for pattern, capability in patterns.items():
            if (project_path / pattern).exists():
                capabilities.append(capability)
        
        return capabilities
    
    async def _explore_hidden_features(self, project: DiscoveredProject) -> List[str]:
        """Discover hidden or undocumented features"""
        
        capabilities = []
        
        # This is where evolution gets interesting - 
        # try random things and see what works
        
        return capabilities
    
    async def _explore_custom_commands(self, project: DiscoveredProject) -> List[str]:
        """Discover project-specific custom commands"""
        
        capabilities = []
        project_path = Path(project.path)
        
        # Look for shell scripts
        for script in project_path.glob('*.sh'):
            if script.is_file() and os.access(script, os.X_OK):
                capabilities.append(f"script:{script.name}")
        
        # Look for Python scripts
        for script in project_path.glob('*.py'):
            if script.is_file():
                # Check if it has a main function or is executable
                try:
                    with open(script) as f:
                        content = f.read()
                        if 'if __name__' in content or script.stat().st_mode & 0o111:
                            capabilities.append(f"python-script:{script.name}")
                except:
                    pass
        
        return capabilities
    
    def get_project_report(self) -> str:
        """Generate a report of discovered projects"""
        
        report = f"""
Project Discovery Report
========================

Total Projects Discovered: {len(self.discovered_projects)}
New This Session: {len(self.new_discoveries)}

Projects by Type:
"""
        
        # Group by type
        by_type = {}
        for project in self.discovered_projects.values():
            if project.type not in by_type:
                by_type[project.type] = []
            by_type[project.type].append(project)
        
        for proj_type, projects in sorted(by_type.items()):
            report += f"\n{proj_type}: {len(projects)}"
            for project in projects[:3]:  # Show first 3
                report += f"\n  - {project.name} ({len(project.capabilities)} capabilities)"
        
        # Most capable projects
        report += "\n\nMost Capable Projects:\n"
        sorted_projects = sorted(
            self.discovered_projects.values(), 
            key=lambda p: len(p.capabilities), 
            reverse=True
        )[:5]
        
        for project in sorted_projects:
            report += f"- {project.name}: {len(project.capabilities)} capabilities\n"
            for cap in project.capabilities[:3]:
                report += f"  • {cap}\n"
        
        return report
