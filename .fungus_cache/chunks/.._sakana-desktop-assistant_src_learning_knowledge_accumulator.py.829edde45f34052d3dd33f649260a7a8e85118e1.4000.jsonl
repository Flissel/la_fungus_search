# file: ..\sakana-desktop-assistant\src\learning\knowledge_accumulator.py | lines: 1-275 | window: 4000
"""
Knowledge Accumulator - Persistent learning across sessions
"""

import os
import json
import logging
from typing import Dict, Any, Set, List
from datetime import datetime
from pathlib import Path

logger = logging.getLogger(__name__)

class KnowledgeAccumulator:
    """Accumulates discovered knowledge permanently across all sessions"""
    
    def __init__(self, knowledge_dir: str = None):
        self.knowledge_dir = Path(knowledge_dir or os.path.expanduser("~/.sakana/knowledge"))
        self.knowledge_dir.mkdir(parents=True, exist_ok=True)
        
        # Permanent knowledge files
        self.commands_db = self.knowledge_dir / "permanent_commands.json"
        self.patterns_db = self.knowledge_dir / "successful_patterns.json"
        self.evolution_history = self.knowledge_dir / "evolution_history.json"
        
        # Load accumulated knowledge
        self.permanent_commands = self._load_permanent_commands()
        self.known_patterns = self._load_known_patterns()
        self.discovery_history = self._load_discovery_history()
        
    def _load_permanent_commands(self) -> Dict[str, Any]:
        """Load all commands ever discovered"""
        
        if self.commands_db.exists():
            try:
                with open(self.commands_db, 'r') as f:
                    data = json.load(f)
                logger.info(f"Loaded {len(data.get('commands', {}))} permanent commands")
                return data
            except Exception as e:
                logger.error(f"Failed to load permanent commands: {e}")
        
        return {
            'commands': {},
            'first_discovered': {},
            'discovery_count': {},
            'last_verified': {}
        }
    
    def _load_known_patterns(self) -> List[Dict[str, Any]]:
        """Load all successful patterns ever found"""
        
        if self.patterns_db.exists():
            try:
                with open(self.patterns_db, 'r') as f:
                    patterns = json.load(f)
                logger.info(f"Loaded {len(patterns)} known successful patterns")
                return patterns
            except Exception as e:
                logger.error(f"Failed to load patterns: {e}")
        
        return []
    
    def _load_discovery_history(self) -> List[Dict[str, Any]]:
        """Load history of all discovery sessions"""
        
        if self.evolution_history.exists():
            try:
                with open(self.evolution_history, 'r') as f:
                    history = json.load(f)
                return history
            except Exception as e:
                logger.error(f"Failed to load history: {e}")
        
        return []
    
    def get_already_known_commands(self) -> Set[str]:
        """Get set of all commands we've ever discovered"""
        
        return set(self.permanent_commands.get('commands', {}).keys())
    
    def add_discovered_command(self, command: str, metadata: Dict[str, Any] = None):
        """Add a newly discovered command to permanent knowledge"""
        
        commands = self.permanent_commands.get('commands', {})
        
        if command not in commands:
            # First time discovering this command
            logger.info(f"NEW PERMANENT DISCOVERY: {command}")
            commands[command] = {
                'first_discovered': datetime.now().isoformat(),
                'metadata': metadata or {},
                'discovery_count': 1
            }
            self.permanent_commands['first_discovered'][command] = datetime.now().isoformat()
        else:
            # We've seen this before
            commands[command]['discovery_count'] = commands[command].get('discovery_count', 0) + 1
            logger.debug(f"Rediscovered known command: {command} (count: {commands[command]['discovery_count']})")
        
        self.permanent_commands['commands'] = commands
        self.permanent_commands['last_verified'][command] = datetime.now().isoformat()
        
        # Save immediately
        self._save_permanent_commands()
    
    def add_successful_pattern(self, pattern: Dict[str, Any]):
        """Add a successful pattern to permanent knowledge"""
        
        # Check if we've seen this exact pattern before
        pattern_str = json.dumps(pattern.get('strategy', {}), sort_keys=True)
        
        for existing in self.known_patterns:
            if json.dumps(existing.get('strategy', {}), sort_keys=True) == pattern_str:
                # Update success count
                existing['success_count'] = existing.get('success_count', 0) + 1
                existing['last_used'] = datetime.now().isoformat()
                logger.debug(f"Known pattern used again (count: {existing['success_count']})")
                self._save_known_patterns()
                return
        
        # New pattern
        logger.info(f"NEW SUCCESSFUL PATTERN DISCOVERED")
        pattern['first_success'] = datetime.now().isoformat()
        pattern['success_count'] = 1
        self.known_patterns.append(pattern)
        
        # Keep only the best patterns (top 100 by success count)
        self.known_patterns.sort(key=lambda p: p.get('success_count', 0), reverse=True)
        self.known_patterns = self.known_patterns[:100]
        
        self._save_known_patterns()
    
    def record_discovery_session(self, session_data: Dict[str, Any]):
        """Record a complete discovery session"""
        
        session = {
            'timestamp': datetime.now().isoformat(),
            'duration': session_data.get('duration'),
            'commands_tested': session_data.get('commands_tested', 0),
            'new_discoveries': session_data.get('new_discoveries', []),
            'rediscoveries': session_data.get('rediscoveries', []),
            'session_id': os.urandom(8).hex()
        }
        
        self.discovery_history.append(session)
        
        # Keep last 100 sessions
        self.discovery_history = self.discovery_history[-100:]
        
        self._save_discovery_history()
        
        # Log session summary
        logger.info(f"Discovery session complete: {len(session['new_discoveries'])} new, "
                   f"{len(session['rediscoveries'])} rediscovered")
    
    def get_discovery_stats(self) -> Dict[str, Any]:
        """Get statistics about accumulated knowledge"""
        
        total_commands = len(self.permanent_commands.get('commands', {}))
        total_patterns = len(self.known_patterns)
        total_sessions = len(self.discovery_history)
        
        # Calculate discovery rate over time
        new_discoveries_per_session = []
        for session in self.discovery_history[-10:]:  # Last 10 sessions
            new_discoveries_per_session.append(len(session.get('new_discoveries', [])))
        
        avg_new_per_session = (sum(new_discoveries_per_session) / len(new_discoveries_per_session) 
                               if new_discoveries_per_session else 0)
        
        return {
            'total_permanent_commands': total_commands,
            'total_successful_patterns': total_patterns,
            'total_discovery_sessions': total_sessions,
            'average_new_discoveries_per_session': avg_new_per_session,
            'knowledge_growth_trend': 'saturating' if avg_new_per_session < 1 else 'growing'
        }
    
    def suggest_unexplored_areas(self) -> List[str]:
        """Suggest areas that might have undiscovered commands"""
        
        suggestions = []
        
        # Analyze patterns in discovered commands
        known_commands = self.get_already_known_commands()
        
        # Look for gaps in command families
        command_families = {
            'text': ['cat', 'more', 'less', 'head', 'tail', 'vim', 'nano', 'emacs'],
            'search': ['find', 'grep', 'ag', 'rg', 'ack', 'fzf', 'locate'],
            'system': ['ps', 'top', 'htop', 'df', 'du', 'free', 'iostat'],
            'network': ['ping', 'curl', 'wget', 'nc', 'telnet', 'ssh', 'scp'],
            'archive': ['tar', 'zip', 'unzip', 'gzip', 'bzip2', '7z', 'rar'],
            'version': ['git', 'svn', 'hg', 'cvs', 'fossil'],
            'build': ['make', 'cmake', 'ninja', 'bazel', 'gradle', 'maven']
        }
        
        for family, commands in command_families.items():
            discovered = sum(1 for cmd in commands if cmd in known_commands)
            if discovered > 0 and discovered < len(commands) / 2:
                suggestions.append(f"Explore more {family} commands - found {discovered}/{len(commands)}")
        
        # Suggest platform-specific exploration
        if 'cmd.exe' in known_commands and 'powershell' not in known_commands:
            suggestions.append("Explore PowerShell commands")
        
        if 'ls' in known_commands and 'exa' not in known_commands:
            suggestions.append("Explore modern alternatives (exa, bat, fd)")
        
        return suggestions
    
    def _save_permanent_commands(self):
        """Save permanent commands database"""
        
        try:
            with open(self.commands_db, 'w') as f:
                json.dump(self.permanent_commands, f, indent=2)
        except Exception as e:
            logger.error(f"Failed to save permanent commands: {e}")
    
    def _save_known_patterns(self):
        """Save successful patterns"""
        
        try:
            with open(self.patterns_db, 'w') as f:
                json.dump(self.known_patterns, f, indent=2)
        except Exception as e:
            logger.error(f"Failed to save patterns: {e}")
    
    def _save_discovery_history(self):
        """Save discovery session history"""
        
        try:
            with open(self.evolution_history, 'w') as f:
                json.dump(self.discovery_history, f, indent=2)
        except Exception as e:
            logger.error(f"Failed to save history: {e}")
    
    def export_knowledge_report(self) -> str:
        """Generate a human-readable knowledge report"""
        
        stats = self.get_discovery_stats()
        suggestions = self.suggest_unexplored_areas()
        
        report = f"""
Sakana Knowledge Accumulation Report
====================================

Total Accumulated Knowledge:
- Permanent Commands: {stats['total_permanent_commands']}
- Successful Patterns: {stats['total_successful_patterns']}  
- Discovery Sessions: {stats['total_discovery_sessions']}

Learning Trend: {stats['knowledge_growth_trend']}
Avg New Discoveries/Session: {stats['average_new_discoveries_per_session']:.1f}

Top Commands by Rediscovery:
"""
        
        # Add most rediscovered commands
        commands = self.permanent_commands.get('commands', {})
        sorted_cmds = sorted(commands.items(), 
                           key=lambda x: x[1].get('discovery_count', 0), 
                           reverse=True)[:10]
        
        for cmd, data in sorted_cmds:
            report += f"- {cmd}: discovered {data.get('discovery_count', 0)} times\n"
        
        if suggestions:
            report += "\nSuggested Exploration Areas:\n"
            for suggestion in suggestions:
                report += f"- {suggestion}\n"
        
        return report
