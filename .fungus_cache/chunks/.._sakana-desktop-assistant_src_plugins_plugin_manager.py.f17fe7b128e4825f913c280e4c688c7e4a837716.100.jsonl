# file: ..\sakana-desktop-assistant\src\plugins\plugin_manager.py | lines: 1-100 | window: 100
import importlib
import inspect
from pathlib import Path
from typing import Dict, Any, List, Optional, Callable
from abc import ABC, abstractmethod
import logging
import json

logger = logging.getLogger(__name__)

class Plugin(ABC):
    """Base class for all plugins"""
    
    def __init__(self):
        self.name = self.__class__.__name__
        self.version = "1.0.0"
        self.description = "Base plugin"
        self.commands = {}
    
    @abstractmethod
    async def initialize(self, assistant):
        """Initialize the plugin with assistant reference"""
        pass
    
    @abstractmethod
    async def handle_command(self, command: str, context: Dict[str, Any]) -> Optional[Dict[str, Any]]:
        """Handle a command if this plugin can process it"""
        pass
    
    def register_command(self, command: str, handler: Callable):
        """Register a command handler"""
        self.commands[command] = handler

class PluginManager:
    """Manages loading and execution of plugins"""
    
    def __init__(self, plugins_dir: Path):
        self.plugins_dir = plugins_dir
        self.plugins: Dict[str, Plugin] = {}
        self.command_map: Dict[str, str] = {}  # command -> plugin_name
    
    async def load_plugins(self):
        """Load all plugins from the plugins directory"""
        
        if not self.plugins_dir.exists():
            logger.warning(f"Plugins directory not found: {self.plugins_dir}")
            return
        
        # Load built-in plugins
        await self._load_builtin_plugins()
        
        # Load user plugins
        for plugin_file in self.plugins_dir.glob("*.py"):
            if plugin_file.name.startswith("_"):
                continue
            
            try:
                await self._load_plugin_file(plugin_file)
            except Exception as e:
                logger.error(f"Failed to load plugin {plugin_file}: {e}")
    
    async def _load_builtin_plugins(self):
        """Load built-in plugins"""
        
        # Example built-in plugins
        from .builtin_plugins import (
            FileManagerPlugin,
            WebSearchPlugin,
            TaskManagerPlugin,
            SystemInfoPlugin
        )
        
        builtin_plugins = [
            FileManagerPlugin(),
            WebSearchPlugin(),
            TaskManagerPlugin(),
            SystemInfoPlugin()
        ]
        
        for plugin in builtin_plugins:
            await self._register_plugin(plugin)
    
    async def _load_plugin_file(self, plugin_file: Path):
        """Load a plugin from a Python file"""
        
        # Import the module
        spec = importlib.util.spec_from_file_location(
            plugin_file.stem,
            plugin_file
        )
        
        if spec and spec.loader:
            module = importlib.util.module_from_spec(spec)
            spec.loader.exec_module(module)
            
            # Find Plugin subclasses
            for name, obj in inspect.getmembers(module):
                if (inspect.isclass(obj) and 
                    issubclass(obj, Plugin) and 
                    obj != Plugin):

# file: ..\sakana-desktop-assistant\src\plugins\plugin_manager.py | lines: 101-177 | window: 100
                    
                    # Instantiate and register
                    plugin = obj()
                    await self._register_plugin(plugin)
    
    async def _register_plugin(self, plugin: Plugin):
        """Register a plugin"""
        
        try:
            # Initialize the plugin
            await plugin.initialize(None)  # Pass assistant reference when available
            
            # Register plugin
            self.plugins[plugin.name] = plugin
            
            # Map commands
            for command in plugin.commands:
                self.command_map[command] = plugin.name
            
            logger.info(f"Loaded plugin: {plugin.name} v{plugin.version}")
            
        except Exception as e:
            logger.error(f"Failed to register plugin {plugin.name}: {e}")
    
    async def handle_command(self, user_input: str, context: Dict[str, Any]) -> Optional[Dict[str, Any]]:
        """Route command to appropriate plugin"""
        
        # Extract command from input
        parts = user_input.strip().split()
        if not parts:
            return None
        
        command = parts[0].lower()
        
        # Check if command is registered
        if command in self.command_map:
            plugin_name = self.command_map[command]
            plugin = self.plugins[plugin_name]
            
            try:
                return await plugin.handle_command(user_input, context)
            except Exception as e:
                logger.error(f"Plugin {plugin_name} error handling command: {e}")
                return {
                    'content': f"Plugin error: {str(e)}",
                    'type': 'error'
                }
        
        return None
    
    def get_available_commands(self) -> List[Dict[str, str]]:
        """Get list of available commands"""
        
        commands = []
        for command, plugin_name in self.command_map.items():
            plugin = self.plugins[plugin_name]
            commands.append({
                'command': command,
                'plugin': plugin_name,
                'description': f"{command} - from {plugin.description}"
            })
        
        return commands
    
    def get_plugin_info(self) -> List[Dict[str, Any]]:
        """Get information about loaded plugins"""
        
        info = []
        for name, plugin in self.plugins.items():
            info.append({
                'name': name,
                'version': plugin.version,
                'description': plugin.description,
                'commands': list(plugin.commands.keys())
            })
        
        return info
