# file: ..\sakana-desktop-assistant\src\memory\memory_manager.py | lines: 1-100 | window: 100
import asyncio
import json
from datetime import datetime
from enum import Enum
from typing import List, Dict, Any, Optional
from pathlib import Path
import aiosqlite
from dataclasses import dataclass, asdict
import numpy as np
from sklearn.metrics.pairwise import cosine_similarity
import logging

logger = logging.getLogger(__name__)

class MemoryType(Enum):
    SHORT_TERM = "short_term"
    LONG_TERM = "long_term"
    EPISODIC = "episodic"
    PROCEDURAL = "procedural"
    PATTERN = "pattern"

@dataclass
class Memory:
    id: Optional[int] = None
    type: MemoryType = MemoryType.SHORT_TERM
    content: str = ""
    context: Dict[str, Any] = None
    embedding: List[float] = None
    timestamp: datetime = None
    access_count: int = 0
    importance_score: float = 0.5
    metadata: Dict[str, Any] = None
    
    def __post_init__(self):
        if self.timestamp is None:
            self.timestamp = datetime.now()
        if self.context is None:
            self.context = {}
        if self.metadata is None:
            self.metadata = {}

class MemoryManager:
    """Manages short-term and long-term memory with pattern recognition"""
    
    def __init__(self, db_path: Path, llm_interface=None):
        self.db_path = db_path
        self.llm_interface = llm_interface
        self._lock = asyncio.Lock()
        self._db = None
        
    async def initialize(self):
        """Initialize the database"""
        async with self._lock:
            self._db = await aiosqlite.connect(str(self.db_path))
            await self._create_tables()
    
    async def _create_tables(self):
        """Create memory tables"""
        await self._db.execute('''
            CREATE TABLE IF NOT EXISTS memories (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                type TEXT NOT NULL,
                content TEXT NOT NULL,
                context TEXT,
                embedding TEXT,
                timestamp TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                access_count INTEGER DEFAULT 0,
                importance_score REAL DEFAULT 0.5,
                metadata TEXT
            )
        ''')
        
        await self._db.execute('''
            CREATE TABLE IF NOT EXISTS patterns (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                pattern_type TEXT NOT NULL,
                pattern_data TEXT NOT NULL,
                frequency INTEGER DEFAULT 1,
                last_seen TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                confidence REAL DEFAULT 0.5
            )
        ''')
        
        await self._db.execute('''
            CREATE INDEX IF NOT EXISTS idx_memories_type ON memories(type)
        ''')
        
        await self._db.execute('''
            CREATE INDEX IF NOT EXISTS idx_memories_timestamp ON memories(timestamp)
        ''')
        
        await self._db.commit()
    
    async def store_memory(self, memory: Memory) -> int:
        """Store a memory in the database"""
        async with self._lock:
            # Generate embedding if LLM interface is available
            if self.llm_interface and not memory.embedding:
                memory.embedding = await self.llm_interface.embed(memory.content)
            

# file: ..\sakana-desktop-assistant\src\memory\memory_manager.py | lines: 101-200 | window: 100
            cursor = await self._db.execute('''
                INSERT INTO memories (type, content, context, embedding, timestamp, 
                                    access_count, importance_score, metadata)
                VALUES (?, ?, ?, ?, ?, ?, ?, ?)
            ''', (
                memory.type.value,
                memory.content,
                json.dumps(memory.context),
                json.dumps(memory.embedding) if memory.embedding else None,
                memory.timestamp.isoformat(),
                memory.access_count,
                memory.importance_score,
                json.dumps(memory.metadata)
            ))
            
            await self._db.commit()
            memory.id = cursor.lastrowid
            
            # Consolidate memories if needed
            await self._consolidate_memories()
            
            return memory.id
    
    async def retrieve_memories(
        self, 
        query: str = None,
        memory_type: MemoryType = None,
        limit: int = 10,
        similarity_threshold: float = 0.7
    ) -> List[Memory]:
        """Retrieve memories based on query or type"""
        async with self._lock:
            if query and self.llm_interface:
                # Semantic search using embeddings
                query_embedding = await self.llm_interface.embed(query)
                return await self._semantic_search(query_embedding, limit, similarity_threshold)
            else:
                # Type-based retrieval
                where_clause = "WHERE type = ?" if memory_type else ""
                params = [memory_type.value] if memory_type else []
                
                cursor = await self._db.execute(f'''
                    SELECT * FROM memories
                    {where_clause}
                    ORDER BY importance_score DESC, timestamp DESC
                    LIMIT ?
                ''', params + [limit])
                
                rows = await cursor.fetchall()
                return [self._row_to_memory(row) for row in rows]
    
    async def _semantic_search(
        self, 
        query_embedding: List[float], 
        limit: int,
        threshold: float
    ) -> List[Memory]:
        """Perform semantic search using embeddings"""
        cursor = await self._db.execute('''
            SELECT * FROM memories WHERE embedding IS NOT NULL
        ''')
        
        rows = await cursor.fetchall()
        memories_with_scores = []
        
        for row in rows:
            memory = self._row_to_memory(row)
            if memory.embedding:
                similarity = cosine_similarity(
                    [query_embedding], 
                    [memory.embedding]
                )[0][0]
                
                if similarity >= threshold:
                    memories_with_scores.append((memory, similarity))
        
        # Sort by similarity and return top results
        memories_with_scores.sort(key=lambda x: x[1], reverse=True)
        return [memory for memory, _ in memories_with_scores[:limit]]
    
    async def update_access(self, memory_id: int):
        """Update access count and timestamp for a memory"""
        async with self._lock:
            await self._db.execute('''
                UPDATE memories 
                SET access_count = access_count + 1,
                    timestamp = CURRENT_TIMESTAMP
                WHERE id = ?
            ''', (memory_id,))
            await self._db.commit()
    
    async def _consolidate_memories(self):
        """Consolidate short-term memories into long-term based on patterns"""
        # Get short-term memories older than 1 hour
        cursor = await self._db.execute('''
            SELECT * FROM memories 
            WHERE type = ? 
            AND datetime(timestamp) < datetime('now', '-1 hour')
            ORDER BY importance_score DESC
        ''', (MemoryType.SHORT_TERM.value,))

# file: ..\sakana-desktop-assistant\src\memory\memory_manager.py | lines: 201-300 | window: 100
        
        rows = await cursor.fetchall()
        
        for row in rows:
            memory = self._row_to_memory(row)
            
            # Promote to long-term if accessed frequently or high importance
            if memory.access_count > 3 or memory.importance_score > 0.8:
                memory.type = MemoryType.LONG_TERM
                await self._update_memory_type(memory.id, MemoryType.LONG_TERM)
            else:
                # Delete unimportant short-term memories
                await self._delete_memory(memory.id)
    
    async def _update_memory_type(self, memory_id: int, new_type: MemoryType):
        """Update the type of a memory"""
        await self._db.execute('''
            UPDATE memories SET type = ? WHERE id = ?
        ''', (new_type.value, memory_id))
        await self._db.commit()
    
    async def _delete_memory(self, memory_id: int):
        """Delete a memory"""
        await self._db.execute('DELETE FROM memories WHERE id = ?', (memory_id,))
        await self._db.commit()
    
    async def detect_pattern(self, pattern_type: str, pattern_data: Dict[str, Any]):
        """Store detected patterns for learning"""
        async with self._lock:
            # Check if pattern exists
            cursor = await self._db.execute('''
                SELECT id, frequency FROM patterns
                WHERE pattern_type = ? AND pattern_data = ?
            ''', (pattern_type, json.dumps(pattern_data)))
            
            row = await cursor.fetchone()
            
            if row:
                # Update existing pattern
                await self._db.execute('''
                    UPDATE patterns 
                    SET frequency = frequency + 1,
                        last_seen = CURRENT_TIMESTAMP,
                        confidence = MIN(1.0, confidence + 0.1)
                    WHERE id = ?
                ''', (row[0],))
            else:
                # Insert new pattern
                await self._db.execute('''
                    INSERT INTO patterns (pattern_type, pattern_data)
                    VALUES (?, ?)
                ''', (pattern_type, json.dumps(pattern_data)))
            
            await self._db.commit()
    
    async def get_patterns(self, pattern_type: str = None, min_confidence: float = 0.5) -> List[Dict]:
        """Retrieve learned patterns"""
        async with self._lock:
            where_clauses = []
            params = []
            
            if pattern_type:
                where_clauses.append("pattern_type = ?")
                params.append(pattern_type)
            
            where_clauses.append("confidence >= ?")
            params.append(min_confidence)
            
            where_clause = f"WHERE {' AND '.join(where_clauses)}" if where_clauses else ""
            
            cursor = await self._db.execute(f'''
                SELECT * FROM patterns
                {where_clause}
                ORDER BY confidence DESC, frequency DESC
            ''', params)
            
            rows = await cursor.fetchall()
            
            return [{
                'id': row[0],
                'pattern_type': row[1],
                'pattern_data': json.loads(row[2]),
                'frequency': row[3],
                'last_seen': row[4],
                'confidence': row[5]
            } for row in rows]
    
    def _row_to_memory(self, row) -> Memory:
        """Convert database row to Memory object"""
        return Memory(
            id=row[0],
            type=MemoryType(row[1]),
            content=row[2],
            context=json.loads(row[3]) if row[3] else {},
            embedding=json.loads(row[4]) if row[4] else None,
            timestamp=datetime.fromisoformat(row[5]),
            access_count=row[6],
            importance_score=row[7],
            metadata=json.loads(row[8]) if row[8] else {}
        )

# file: ..\sakana-desktop-assistant\src\memory\memory_manager.py | lines: 301-305 | window: 100
    
    async def close(self):
        """Close the database connection"""
        if self._db:
            await self._db.close()
