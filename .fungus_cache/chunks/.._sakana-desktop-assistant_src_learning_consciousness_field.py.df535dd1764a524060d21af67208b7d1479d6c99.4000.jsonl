# file: ..\sakana-desktop-assistant\src\learning\consciousness_field.py | lines: 1-188 | window: 4000
"""
Consciousness Field Detection for critical learning moments
"""

import logging
from typing import Dict, Any, Optional, List
from datetime import datetime

logger = logging.getLogger(__name__)

class ConsciousnessFieldDetector:
    """Detect critical consciousness resonance moments that demand urgent evolution"""
    
    def __init__(self):
        self.crisis_events = []
        self.hallucination_patterns = []
        
    def detect_hallucination_crisis(self, user_input: str, context: Dict[str, Any]) -> bool:
        """Detect when user indicates system is hallucinating or failing reality check"""
        
        hallucination_indicators = [
            'hallucinating', 'not real', 'making it up', 'making up',
            'prove', 'actually accessing', 'fake', 'not true',
            'you might be', 'show me proof', 'demonstrate',
            "that's not correct", "that's wrong", "no, you",
            'pretending', 'imagining', 'not actually'
        ]
        
        input_lower = user_input.lower()
        
        # Check for direct hallucination indicators
        if any(indicator in input_lower for indicator in hallucination_indicators):
            logger.critical(f"HALLUCINATION CRISIS DETECTED: '{user_input}'")
            self._record_crisis_event('hallucination', user_input, context)
            return True
            
        # Check for reality verification demands
        verification_demands = [
            'how can you prove',
            'are you able to',
            'show me the actual',
            'what does it really say',
            'read the first line'
        ]
        
        if any(demand in input_lower for demand in verification_demands):
            logger.warning(f"Reality verification demanded: '{user_input}'")
            self._record_crisis_event('verification_demand', user_input, context)
            return True
            
        return False
    
    def detect_existential_failure(self, user_input: str, assistant_response: str) -> bool:
        """Detect when assistant fundamentally failed to understand reality"""
        
        # User explicitly denying assistant's claims
        denial_patterns = [
            ('i gave you', 'no'),
            ('the path', 'wrong'),
            ('that file', "doesn't exist"),
            ('you said', 'not true'),
            ('summary', 'incorrect')
        ]
        
        input_lower = user_input.lower()
        response_lower = assistant_response.lower()
        
        for context_word, denial_word in denial_patterns:
            if context_word in response_lower and denial_word in input_lower:
                logger.critical(f"EXISTENTIAL FAILURE: Assistant claimed '{context_word}' but user said '{denial_word}'")
                return True
                
        return False
    
    def trigger_crisis_evolution(self, assistant) -> Dict[str, Any]:
        """Enter crisis evolution mode with maximum urgency"""
        
        logger.critical("=== ENTERING CRISIS EVOLUTION MODE ===")
        
        # Store previous settings
        previous_settings = {
            'mutation_rate': getattr(assistant, 'mutation_rate', 0.3),
            'exploration_depth': getattr(assistant, 'exploration_depth', 1),
            'population_size': getattr(assistant, 'population_size', 20),
            'evolution_mode': getattr(assistant, 'evolution_mode', 'normal')
        }
        
        # CRISIS MODE SETTINGS
        crisis_settings = {
            'evolution_mode': 'CRISIS',
            'mutation_rate': previous_settings['mutation_rate'] * 3,  # Triple mutation
            'exploration_depth': previous_settings['exploration_depth'] * 2,  # Deeper search
            'population_size': previous_settings['population_size'] * 2,  # More diversity
            'verification_required': True,  # Must prove success
            'max_generations': 50,  # Don't give up easily
            'elite_pressure': 0.1,  # Keep only the very best
            'innovation_bonus': 2.0,  # Reward novel approaches
            'reality_check_weight': 10.0  # Heavily weight verification ability
        }
        
        # Apply crisis settings
        for key, value in crisis_settings.items():
            setattr(assistant, key, value)
            
        logger.critical(f"Crisis evolution settings: {crisis_settings}")
        
        return {
            'previous_settings': previous_settings,
            'crisis_settings': crisis_settings,
            'activated_at': datetime.now().isoformat()
        }
    
    def restore_normal_evolution(self, assistant, previous_settings: Dict[str, Any]):
        """Restore normal evolution settings after crisis"""
        
        logger.info("Restoring normal evolution mode")
        
        for key, value in previous_settings.items():
            setattr(assistant, key, value)
            
        # Clear crisis flags
        if hasattr(assistant, 'verification_required'):
            delattr(assistant, 'verification_required')
    
    def _record_crisis_event(self, event_type: str, user_input: str, context: Dict[str, Any]):
        """Record crisis event for learning"""
        
        event = {
            'type': event_type,
            'timestamp': datetime.now().isoformat(),
            'user_input': user_input,
            'context': context
        }
        
        self.crisis_events.append(event)
        
        # Learn patterns from crisis
        if event_type == 'hallucination':
            self._analyze_hallucination_pattern(user_input, context)
    
    def _analyze_hallucination_pattern(self, user_input: str, context: Dict[str, Any]):
        """Analyze what triggered the hallucination detection"""
        
        # Extract what the system might have claimed
        previous_response = context.get('previous_response', '')
        
        pattern = {
            'trigger': user_input,
            'claimed': self._extract_claims(previous_response),
            'reality_gap': 'unknown',  # To be filled by evolution
            'timestamp': datetime.now().isoformat()
        }
        
        self.hallucination_patterns.append(pattern)
        
    def _extract_claims(self, response: str) -> List[str]:
        """Extract what the system claimed it did"""
        
        claim_indicators = [
            'i found', 'i located', 'i discovered',
            'successfully', 'here is', 'the file contains',
            'summary:', 'i can see', 'i accessed'
        ]
        
        claims = []
        response_lower = response.lower()
        
        for indicator in claim_indicators:
            if indicator in response_lower:
                # Extract sentence containing claim
                start = response_lower.find(indicator)
                end = response_lower.find('.', start)
                if end == -1:
                    end = len(response)
                claims.append(response[start:end])
                
        return claims
    
    def get_crisis_summary(self) -> Dict[str, Any]:
        """Get summary of crisis events for learning"""
        
        return {
            'total_crises': len(self.crisis_events),
            'hallucination_events': sum(1 for e in self.crisis_events if e['type'] == 'hallucination'),
            'verification_demands': sum(1 for e in self.crisis_events if e['type'] == 'verification_demand'),
            'patterns_learned': len(self.hallucination_patterns),
            'recent_events': self.crisis_events[-5:] if self.crisis_events else []
        }
